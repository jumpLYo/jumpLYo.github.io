<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>mysql索引 | open1024</title><meta name="keywords" content="MYSQL,数据库优化"><meta name="author" content="Eric"><meta name="copyright" content="Eric"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQL索引索引的优点最典型的例子就是查新华字典，通过查找目录快速定位到查找的字  大大减少了服务器需要扫描的数量 帮助服务器避免排序和临时表 将IO变成顺序IO 尽可能的降低磁盘的寻址时间，也就是局部性原理，就是很大一部分数据在未来的一段时间被连续访问 在复制1G压缩包 和 1G小文件，前者的速度会大于后者 减少IO的量，例如写SQL语句的时候，不要写 select * 减少IO的次数，一次I"><meta property="og:type" content="article"><meta property="og:title" content="mysql索引"><meta property="og:url" content="http://blog.open1024.top/posts/71014c5a.html"><meta property="og:site_name" content="open1024"><meta property="og:description" content="MySQL索引索引的优点最典型的例子就是查新华字典，通过查找目录快速定位到查找的字  大大减少了服务器需要扫描的数量 帮助服务器避免排序和临时表 将IO变成顺序IO 尽可能的降低磁盘的寻址时间，也就是局部性原理，就是很大一部分数据在未来的一段时间被连续访问 在复制1G压缩包 和 1G小文件，前者的速度会大于后者 减少IO的量，例如写SQL语句的时候，不要写 select * 减少IO的次数，一次I"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://blog.open1024.top/images/mysqlindex.jpg"><meta property="article:published_time" content="2021-08-11T16:08:29.934Z"><meta property="article:modified_time" content="2021-08-11T16:20:18.192Z"><meta property="article:author" content="Eric"><meta property="article:tag" content="MYSQL"><meta property="article:tag" content="数据库优化"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://blog.open1024.top/images/mysqlindex.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.open1024.top/posts/71014c5a"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><meta name="google-site-verification" content="OXQysnRBIPAXouOGPdItz-SSl91YTCe4f8PPNjv5fQ4"><meta name="sogou_site_verification" content="sYMoeIzbyO"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?6fb92c8f2276bc3cb1c411e95f4797f9";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"mysql索引",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-08-12 00:20:18"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/open10242.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/images/mysqlindex.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">open1024</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">mysql索引</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-11T16:08:29.934Z" title="发表于 2021-08-12 00:08:29">2021-08-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-11T16:20:18.192Z" title="更新于 2021-08-12 00:20:18">2021-08-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MYSQL/">MYSQL</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><p>最典型的例子就是查新华字典，通过查找目录快速定位到查找的字</p><ul><li>大大减少了服务器需要扫描的数量</li><li>帮助服务器避免排序和临时表</li><li>将IO变成顺序IO<ul><li>尽可能的降低磁盘的寻址时间，也就是局部性原理，就是很大一部分数据在未来的一段时间被连续访问</li><li>在复制1G压缩包 和 1G小文件，前者的速度会大于后者</li><li>减少IO的量，例如写SQL语句的时候，不要写 select *</li><li>减少IO的次数，一次IO能搞定的事，不使用3次IO</li></ul></li></ul><h2 id="索引的用处"><a href="#索引的用处" class="headerlink" title="索引的用处"></a>索引的用处</h2><ul><li>快速查找匹配where子句的行</li><li>从consideration中消除行，如果可以在多个索引之间进行选择，mysql通常会使用栈找到最少行的索引</li><li>如果表具有多列索引，则优化器可以使用索引的最左匹配前缀来查找</li><li>当有表连接的时候，从其他表检测行数据</li><li>查找特定索引列min或max值</li><li>如果排序或分组是，在可用索引的最左前缀上完成的，则对表进行排序和分组</li><li>在某些清空下，可以优化查询以检索值而无需查询数据行</li></ul><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>如果你在创建索引的时候，使用的是主键这个值，那么就是主键索引，primary key</p><p>我们建表的时候，例如下面这个建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_blog_sort` (</span><br><span class="line">  `uid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;唯一uid&#x27;</span>,</span><br><span class="line">  `sort_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类内容&#x27;</span>,</span><br><span class="line">  `content` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类简介&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0000-00-00 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0000-00-00 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `status` tinyint(<span class="number">1</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">  `sort` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;排序字段，越大越靠前&#x27;</span>,</span><br><span class="line">  `click_count` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;点击数&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`uid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;博客分类表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这里面有使用到 PRIMARY KEY (<code>uid</code>)，这就是主键索引</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引 类似于普通索引，索引列的值必须唯一</p><p>唯一索引和主键索引的区别就是，唯一索引允许出现空值，而主键索引不能为空</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index index_name <span class="keyword">on</span> <span class="keyword">table</span>(<span class="keyword">column</span>)</span><br></pre></td></tr></table></figure><p>或者创建表时指定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unique</span> index_name <span class="keyword">column</span></span><br></pre></td></tr></table></figure><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>当我们需要建立索引的字段，既不是主键索引，也不是唯一索引</p><p>那么就可以创建一个普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index  index_name <span class="keyword">on</span> <span class="keyword">table</span>(<span class="keyword">column</span>)</span><br></pre></td></tr></table></figure><p>或者创建表时指定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>(..., index index_name <span class="keyword">column</span>)</span><br></pre></td></tr></table></figure><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>lunce、solr和ElasticSearch就是做全文检索的，里面涉及到了倒排索引的概念，mysql很少使用全文索引。</p><p>要用来查找文本中的关键字，不是直接与索引中的值相比较，像是一个搜索引擎，配合 match against 使用，现在只有char，varchar，text上可以创建索引，在数据量比较大时，先将数据放在一个没有全文索引的表里，然后在利用create index创建全文索引，比先生成全文索引在插入数据快很多。</p><h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>目前，在业务不是特别复杂的时候，可能使用一个列作为索引，或者直接采用主键索引即可，但是如果业务变得复杂的时候，就需要用到组合索引，通过对多个列建立索引。</p><p>组合索引的用处，假设我现在表有个多个字段：id、name、age、gender，然后我经常使用以下的查询条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;xx&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> xx</span><br></pre></td></tr></table></figure><p>这个时候，我们就可以通过组合 name 和 age 来建立一个组合索引，加快查询效率，建立成组合索引后，我的索引将包含两个key值</p><p>在多个字段上创建索引，遵循<strong>最左匹配</strong>原则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index index_name(a,b,c);</span><br></pre></td></tr></table></figure><h2 id="索引的使用与否"><a href="#索引的使用与否" class="headerlink" title="索引的使用与否"></a>索引的使用与否</h2><h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><p>MySQL每次只使用一个索引，与其说 数据库查询只能用一个索引，倒不如说，和全表扫描比起来，去分析两个索引 B+树更耗费时间，所以where A=a and B=b 这种查询使用（A，B）的组合索引最佳，B+树根据（A，B）来排序。</p><ul><li>主键，unique字段</li><li>和其他表做连接的字段需要加索引</li><li>在where 里使用 &gt;, &gt;=, = , &lt;, &lt;=, is null 和 between等字段。</li><li>使用不以通配符开始的like，where A like ‘China%’</li><li>聚合函数里面的 MIN()， MAX()的字段</li><li>order by 和 group by字段</li></ul><h3 id="何时不使用索引"><a href="#何时不使用索引" class="headerlink" title="何时不使用索引"></a>何时不使用索引</h3><ul><li>表记录太少</li><li>数据重复且分布平均的字段（只有很少数据的列）；</li><li>经常插入、删除、修改的表要减少索引</li><li>text，image 等类型不应该建立索引，这些列的数据量大（加入text的前10个字符唯一，也可以对text前10个字符建立索引）</li><li>MySQL能估计出全表扫描比使用索引更快的时候，不使用索引</li></ul><h3 id="索引何时失效"><a href="#索引何时失效" class="headerlink" title="索引何时失效"></a>索引何时失效</h3><ul><li>组合索引为使用最左前缀，例如组合索引（A，B），where B = b 不会使用索引</li><li>like未使用最左前缀，where A like “%China”</li><li>搜索一个索引而在另一个索引上做 order by， where A = a order by B，只会使用A上的索引，因为查询只使用一个索引。</li><li>or会使索引失效。如果查询字段相同，也可以使用索引。例如 where A = a1 or A = a2（生效），where A=a or B = b （失效）</li><li>在索引列上的操作，函数upper()等，or、！ = （&lt;&gt;）,not in 等</li></ul><h2 id="面试技术名词"><a href="#面试技术名词" class="headerlink" title="面试技术名词"></a>面试技术名词</h2><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>首先我们需要知道，我们建立几个索引，就会生成几棵B+Tree，但是带有原始数据行的B+Tree只有一棵，另外一棵树上的叶子节点带的是主键值。</p><p>例如，我们通过主键建立了主键索引，然后在叶子节点上存放的是我们的数据</p><img src="/posts/71014c5a/image-20200629094621998.png" title="image-20200629094621998"><p>当我们创建了两个索引时，一个是主键，一个是name，它还会在生成一棵B+Tree，这棵树的叶子节点存放的是主键，当我们通过name进行查找的时候，会得到一个主键，然后在通过主键再去上面的这个主键B+Tree中进行查找，我们称这个操作为 ==<strong>回表</strong>==</p><img src="/posts/71014c5a/image-20200629094800800.png" title="image-20200629094800800"><p>当我们的SQL语句使用的是下面这种的时候，它会查找第一颗树，直接返回我们的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb where id = 1</span><br></pre></td></tr></table></figure><p>当我们使用下面这种查询的时候，它会先查找第二棵树得到我们的主键，然后拿着主键再去查询第一棵树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb  where name = &#x27;gang&#x27;</span><br></pre></td></tr></table></figure><p>回表就是<strong>通过普通列的索引进行检索，然后再去主键列进行检索</strong>，这个操作就是回表</p><p>==但是我们在使用检索的时候，尽量避免回表，因为这会造成两次B+Tree的查询，假设一次B+Tree查询需要三次IO操作，那么查询两次B+Tree就需要六次IO操作。==</p><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>我们看下面的两个SQL语句，看看它们的查询过程是一样的么？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> tb <span class="keyword">where</span> name <span class="operator">=</span> zhou</span><br></pre></td></tr></table></figure><p>答案是不一样的，首先我们看第二个语句，就是要输出的列中，就是我们的主键，当我们通过name建立的B+Tree进行查询的时候</p><img src="/posts/71014c5a/image-20200629094800800.png" title="image-20200629094800800"><p>我们可以直接找到我们的数据，并得到主键，但是因为我们要返回的就是name，此时说明数据存在了，那么就直接把当前的name进行返回，而不需要通过主键再去主键B+Tree中进行查询。</p><p>这样一个不需要进行回表操作的过程，我们称为<strong>索引覆盖</strong></p><h3 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h3><p>这里提到的 <strong>最左匹配</strong> 和 <strong>索引下推</strong> 都是针对于组合索引的。</p><p>例如，我们有这样一个索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name  age：组合索引</span><br></pre></td></tr></table></figure><p>必须要先匹配name，才能匹配到age。这个我们就被称为最左匹配</p><p>例如下面的几条SQL语句，那些语句不会使用组合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> ? <span class="keyword">and</span> age <span class="operator">=</span> ?</span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> ?</span><br><span class="line"><span class="keyword">where</span> age <span class="operator">=</span> ?</span><br><span class="line"><span class="keyword">where</span> age <span class="operator">=</span> ? <span class="keyword">and</span> name <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure><p>根据最左匹配原则，我们的 3 不会使用组合索引的。</p><p>那为什么4的顺序不一样，也会使用组合索引呢？</p><p>其实内部的优化器会进行调整，例如下面的一个连表操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb1 <span class="keyword">join</span> tb2 <span class="keyword">on</span> tb1.id <span class="operator">=</span> tb2.id</span><br></pre></td></tr></table></figure><p>其实在加载表的时候，并不一定是先加载tb1，在加载tb2，而是可能根据表的大小决定的，小的表优先加载进内存中。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>在说索引下推的时候，我们首先在举两个例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb1 <span class="keyword">where</span> name <span class="operator">=</span> ? <span class="keyword">and</span> age <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure><p>在mysq 5.6之前，会先根据name去存储引擎中拿到所有的数据，然后在server层对age进行数据过滤</p><p>在mysql5.6之后，根据name 和 age两个列的值去获取数据，直到把数据返回。</p><p>通过对比能够发现，第一个的效率低，第二个的效率高，因为整体的IO量少了，原来是把数据查询出来，在server层进行筛选，而现在<strong>在存储引擎层面进行筛选，然后返回结果</strong>。我们把这个过程就称为 <strong>索引下推</strong></p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><h4 id="CBO"><a href="#CBO" class="headerlink" title="CBO"></a>CBO</h4><p>基于成本的优化</p><h4 id="RBO"><a href="#RBO" class="headerlink" title="RBO"></a>RBO</h4><p>基于规则的优化</p><img src="/posts/71014c5a/image-20200629110258878.png" title="image-20200629110258878"><h2 id="索引匹配方式"><a href="#索引匹配方式" class="headerlink" title="索引匹配方式"></a>索引匹配方式</h2><h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>全值匹配指的是和索引中所有的列进行匹配</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> staffs <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;July&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">23</span> <span class="keyword">and</span> pos <span class="operator">=</span> <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure><p>而我们建立了一个 包含 name、age、pos的组合索引，使用上面的SQL语句，就会进行全值匹配</p><h3 id="匹配最左前缀"><a href="#匹配最左前缀" class="headerlink" title="匹配最左前缀"></a>匹配最左前缀</h3><p>只匹配前面的几列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> staffs <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;July&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">23</span></span><br></pre></td></tr></table></figure><p>这个时候，只使匹配了前面两个列，而没有使用第三个列</p><p>现在我们使用下面的SQL语句进行验证，但我们输出值只包含ID的时候</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id <span class="keyword">from</span> staffs <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们查看其任务计划，在某尾有 Extra字段，如果是Using index 表示是使用了<strong>覆盖索引</strong></p><img src="/posts/71014c5a/image-20200629144438346.png" title="image-20200629144438346"><p>然后我们在查看下面这条SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> staffs <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过查看任务计划，发现extra字段是NULL，说明没有使用覆盖索引</p><img src="/posts/71014c5a/image-20200629145948288.png" title="image-20200629145948288"><h3 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h3><p>可以匹配某一列值的开头部分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> staffs <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;J%&#x27;</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> staffs <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;%y&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h3><p>可以查找某个范围的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> staffs <span class="keyword">where</span> name <span class="operator">&gt;</span> <span class="string">&#x27;Mary&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="headerlink" title="精确匹配某一列并范围匹配另外一列"></a>精确匹配某一列并范围匹配另外一列</h3><p>可以查询某一列的全部和第二列的部分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> staffs <span class="keyword">where</span> name <span class="operator">=</span> &quot;July&quot; <span class="keyword">and</span> age <span class="operator">&gt;</span> <span class="number">25</span></span><br></pre></td></tr></table></figure><h3 id="只访问索引的查询"><a href="#只访问索引的查询" class="headerlink" title="只访问索引的查询"></a>只访问索引的查询</h3><p>查询的时候值需要访问索引，不需要访问数据行，本质上就是索引覆盖</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> name,age,pos <span class="keyword">from</span> staffs <span class="keyword">where</span> name<span class="operator">=</span>&quot;July&quot; <span class="keyword">and</span> age<span class="operator">=</span><span class="number">25</span> <span class="keyword">and</span> pos <span class="operator">=</span> &quot;dev&quot;</span><br></pre></td></tr></table></figure><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>基于哈希的实现，只有精确匹配索引所有的列的查询才有效，在mysql中，只有memory的存储引擎显式支持哈希索引，哈希索引自身只需存储对应的hash值，索引的结构十分紧凑，这让哈希索引查找的速度非常快。</p><h3 id="哈希索引的限制"><a href="#哈希索引的限制" class="headerlink" title="哈希索引的限制"></a>哈希索引的限制</h3><ul><li>哈希索引值包含哈希值和行指针，而不<strong>存储字段值</strong>。索引不能使用索引中的值来避免读取行</li><li>哈希索引数据并不是按照索引值顺序存储的，所以<strong>无法进行排序</strong></li><li>哈希索引<strong>不支持部分列匹配查找</strong>，哈希索引是使用索引列的全部内容来计算哈希值</li><li>哈希索引<strong>支持等值比较查询，也不支持任何范围查询</strong></li><li>访问哈希索引的数据非常快，除非有很多哈希冲突，当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较，知道找到所有符合条件的行</li><li>哈希冲突比较多的话，维护的代价也会很高</li></ul><h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，聚簇索引就是按每张表的主键构造一棵B+树，同时在叶子节点中存放整张表的行记录数据，于是也将聚簇索引的叶子节点称为数据页，这个特性就决定了索引表中的数据也是索引的一部分。</p><p>==一句话来说：将数据存储与索引放到了一块，找到索引也就找到了数据</p><p>我们日常的工作中，根据实际情况自行添加的索引，都是辅助索引或者称为普通索引，辅助索引就是为了查找主键索引的二级索引，先找到主键索引然后再通过主键索引找数据，但是可能会存在<strong>回表</strong>的问题。</p><h3 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h3><ul><li>数据访问更快，因为聚簇索引将索引和数据保存在一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对主键的排序和范围查找速度非常快</li></ul><h3 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h3><ul><li>插入速度严重依赖于排序，按照主键的顺序插入是最快的方式，否者会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列作为主键</li><li>更新主键的代价很高，因为将会导致被更新的行移动，因此，对于InnoDB表，我们一般定义主键不可更新</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次 根据主键值查找行数据，一般我们需要尽量避免出现索引的二次查找，这个时候，用到的就是<strong>索引的覆盖</strong></li></ul><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，需要二次查找</p><ul><li><h2 id="结合图再仔细点看"><a href="#结合图再仔细点看" class="headerlink" title="结合图再仔细点看"></a>结合图再仔细点看</h2><img src="/posts/71014c5a/img_16285884451045.png"></li></ul><ol><li><p>InnoDB使用的是聚簇索引，将<strong>主键组织到一棵B+树</strong>中，而<strong>行数据就储存在叶子节点</strong>上，若使用”where id = 14”这样的条件查找主键，则<strong>按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据</strong>。</p></li><li><p>若<strong>对Name列进行条件搜索，则需要两个步骤</strong>：<strong>第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键</strong>。第二步<strong>使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据</strong>。（<strong>重点在于通过其他键需要建立辅助索引</strong>）</p></li></ol><p>MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p><h2 id="组合索引-1"><a href="#组合索引-1" class="headerlink" title="组合索引"></a>组合索引</h2><p>当包含多个列为索引，需要注意的是正确的顺序依赖于该索引的查询，同时需要考虑如何更好的满足排序和分组的需要</p><img src="/posts/71014c5a/image-20200629160704401.png" title="image-20200629160704401"><p>第4个不走索引，是因为不满足最左匹配原则</p><p>第5个，因为跨过了b，所以只走a的索引</p><h2 id="优化细节"><a href="#优化细节" class="headerlink" title="优化细节"></a>优化细节</h2><ul><li><p>当使用索引列进行查询的时候，尽量不要使用表达式，把计算放到业务层而不是数据库层</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> actor_id <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">select</span> actor_id <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id<span class="operator">+</span><span class="number">1</span> <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>第一条语句走索引</p><img src="/posts/71014c5a/image-20200629161629049.png" title="image-20200629161629049"><p>而第二条语句没有走主键索引</p><img src="/posts/71014c5a/image-20200629161641522.png" title="image-20200629161641522"></li><li><p>尽量使用主键查询，而不是其它索引，因为<strong>主键查询不会触发回表操作</strong></p></li><li><p>使用前缀索引</p></li></ul><p>有时候需要索引很长的字符串，这会让索引变得大且满，通常情况下可以使用某个列开始的部分字符串，这样大大的节约了索引空间，从而提高索引效率，但这会降低索引的选择性，索引的选择性是指不重复的索引值和数据表记录总数的比值，范围从1/#T 到 1 之间，索引的选择性越高，则查询效率越高，因为选择性更高的索引可以让mysql在查找的时候过滤掉更多的行。</p><p>一般情况下，某个列前缀的选择性也是足够高的，足以满足查询的性能，但是对应BLOG，TEXT，VARCHAR类型的列，必须要使用前缀索引，因为mysql不允许索引这些列的完整长度，使用该方法的诀窍在于选择足够长的前缀以保证较高的选择性，通过又不能太长 。</p><ul><li>使用索引扫描来进行排序</li><li>union、all、in、or都能使用索引，但是推荐使用in</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> actor_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关于or到底走不走索引，必须根据实际情况进行考虑</span></span><br></pre></td></tr></table></figure><ul><li>范围列可以使用到索引</li></ul><p>例如 范围条件是：&lt;、&lt;=、&gt;、&gt;=、between</p><p>范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列，所以一般如果我们使用组合索引的时候，最好不要使用范围查找</p><img src="/posts/71014c5a/image-20200629160704401.png" title="image-20200629160704401"><p>如倒数第一个所示，因为中间b使用了范围查找，所以后面的c是无法使用索引的，只能是a和b才能使用索引</p><ul><li>强制类型转换会让索引失效，进行全表查询</li></ul><p>例如下面这样一个例子所示，我们对 phone字段进行了强制类型转换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">13800001234</span>  <span class="comment">-- 不会触发索引（触发了字符串到整型转换）</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;13800001234&#x27;</span>  <span class="comment">-- 触发索引</span></span><br></pre></td></tr></table></figure><ul><li>更新十分频繁，数据区分度不高的字段上不宜建立索引</li></ul><p>更新会变更B+树，更新 频繁的字段建立索引会大大降低数据库性能</p><p>类似于性别这列的区分度不高的字段，建立索引是没有意义的，不能有效的过滤数据</p><p>一般区分度在百分80以上的时候，就可以建立索引，区分度可以使用 count(distinct(列名)) / count(*) 来进行计算</p><ul><li>创建索引的列，不允许为null，可能会得到不符合预期的结果</li><li>当需要进行表连接的时候，最好不要超过三张表，因为需要join的字段，数据类型必须一致（阿里规约）<ul><li>允许数据的冗余，从而加快查询的效率</li><li>目前是范式和反范式的混合使用</li></ul></li><li>能使用limit的时候，尽量使用limit</li><li>单表索引建议控制在5个以内</li><li>单索引字段不允许超过5个（组合索引）</li><li>创建索引的时候应该尽量避免以下错误的概念</li></ul><p>索引不是越多越好，不要在不了解系统的情况下进行优化</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.cnblogs.com/jiawen010/p/11805241.html">https://www.cnblogs.com/jiawen010/p/11805241.html</a></p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.bilibili.com/video/BV1d5411p7MY?from=search&amp;seid=6712050221639355647">https://www.bilibili.com/video/BV1d5411p7MY?from=search&amp;seid=6712050221639355647</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">Eric</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="http://blog.open1024.top/posts/71014c5a.html">http://blog.open1024.top/posts/71014c5a.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.open1024.top" target="_blank">open1024</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MYSQL/">MYSQL</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/">数据库优化</a></div><div class="post_share"><div class="social-share" data-image="/images/mysqlindex.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/538b504f.html"><img class="prev-cover" src="/images/bloomfilter.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">什么是布隆过滤器</div></div></a></div><div class="next-post pull-right"><a href="/posts/64d023f0.html"><img class="next-cover" src="/images/linux.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux系统中的loadaverage</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/open10242.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Eric</div><div class="author-info__description">让编程不在难学，让技术与生活更加有趣</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/jumpLYo"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/jumpLYo" target="_blank" title="Github" rel="external nofollow noopener noreferrer"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:330296190@qq.com" target="_blank" title="Email" rel="external nofollow noopener noreferrer"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95"><span class="toc-text">MySQL索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">索引的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%94%A8%E5%A4%84"><span class="toc-text">索引的用处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">索引的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-text">主键索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-text">唯一索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-text">普通索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-text">全文索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-text">组合索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%90%A6"><span class="toc-text">索引的使用与否</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">索引的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">何时不使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BD%95%E6%97%B6%E5%A4%B1%E6%95%88"><span class="toc-text">索引何时失效</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E5%90%8D%E8%AF%8D"><span class="toc-text">面试技术名词</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%A1%A8"><span class="toc-text">回表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96"><span class="toc-text">索引覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D"><span class="toc-text">最左匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-text">索引下推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-text">优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CBO"><span class="toc-text">CBO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RBO"><span class="toc-text">RBO</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%8C%B9%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">索引匹配方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D"><span class="toc-text">全值匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80"><span class="toc-text">匹配最左前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%88%97%E5%89%8D%E7%BC%80"><span class="toc-text">匹配列前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E8%8C%83%E5%9B%B4%E5%80%BC"><span class="toc-text">匹配范围值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E7%A1%AE%E5%8C%B9%E9%85%8D%E6%9F%90%E4%B8%80%E5%88%97%E5%B9%B6%E8%8C%83%E5%9B%B4%E5%8C%B9%E9%85%8D%E5%8F%A6%E5%A4%96%E4%B8%80%E5%88%97"><span class="toc-text">精确匹配某一列并范围匹配另外一列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AE%BF%E9%97%AE%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-text">只访问索引的查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="toc-text">哈希索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">哈希索引的限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">聚簇索引和非聚簇索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">聚簇索引的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">聚簇索引的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">非聚簇索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E5%9B%BE%E5%86%8D%E4%BB%94%E7%BB%86%E7%82%B9%E7%9C%8B"><span class="toc-text">结合图再仔细点看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95-1"><span class="toc-text">组合索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%BB%86%E8%8A%82"><span class="toc-text">优化细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/d49557c.html" title="大端小端二进制与字节的转换"><img src="/images/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="大端小端二进制与字节的转换"></a><div class="content"><a class="title" href="/posts/d49557c.html" title="大端小端二进制与字节的转换">大端小端二进制与字节的转换</a><time datetime="2021-08-23T14:23:10.000Z" title="发表于 2021-08-23 22:23:10">2021-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/aa3d54aa.html" title="mysql运维工具之percona-toolkit的安装与使用"><img src="/images/mysql.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="mysql运维工具之percona-toolkit的安装与使用"></a><div class="content"><a class="title" href="/posts/aa3d54aa.html" title="mysql运维工具之percona-toolkit的安装与使用">mysql运维工具之percona-toolkit的安装与使用</a><time datetime="2021-08-12T14:17:23.230Z" title="发表于 2021-08-12 22:17:23">2021-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/538b504f.html" title="什么是布隆过滤器"><img src="/images/bloomfilter.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="什么是布隆过滤器"></a><div class="content"><a class="title" href="/posts/538b504f.html" title="什么是布隆过滤器">什么是布隆过滤器</a><time datetime="2021-08-12T13:43:27.904Z" title="发表于 2021-08-12 21:43:27">2021-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/71014c5a.html" title="mysql索引"><img src="/images/mysqlindex.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="mysql索引"></a><div class="content"><a class="title" href="/posts/71014c5a.html" title="mysql索引">mysql索引</a><time datetime="2021-08-11T16:08:29.934Z" title="发表于 2021-08-12 00:08:29">2021-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/64d023f0.html" title="Linux系统中的loadaverage"><img src="/images/linux.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Linux系统中的loadaverage"></a><div class="content"><a class="title" href="/posts/64d023f0.html" title="Linux系统中的loadaverage">Linux系统中的loadaverage</a><time datetime="2021-08-11T14:07:16.000Z" title="发表于 2021-08-11 22:07:16">2021-08-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Eric</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script></div></body></html>